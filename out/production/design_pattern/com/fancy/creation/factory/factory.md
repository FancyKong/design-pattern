#工厂模式
工厂模式主要是为了解决,让一个工厂为我们建造一个我们需要的对象即可
在开发中,假如负责开发接口A的团队为生产者,依赖接口A的团队为消费者
站在消费者的角度看,我要用的只是接口A的一个对象而已
最好是我什么都不用管,你直接给我一个对象用,对不对?
如果没有一个第三方为我提供这个对象,我还得去知道这个接口的实现类有哪些,还得知道实现类的构造函数参数的意义是什么等等
那如果生产者提供了一个第三方直接返回这个接口A的对象,那么就很方便我消费者获取了
无论接口A的实现类有多少个,构造函数的参数有多复杂,都不是消费者应该关心的
消费者只需知道调用工厂便能得到一个对象,不用为这个对象的构造负责
站在生产者的角度看,接口A的实现有很多种,比如我用数组能够实现接口A,我用链表也能够实现
某一天我发现,用链表实现会比数组更有效,想提倡消费者都用这个链表实现类
这个时候需要搜出所有依赖了这个接口A的消费者,并把他们的new 指令全部改变
这时候如果我自己维护一个第三方直接为所有消费者提供这个对象,无论我想用什么实现,只需要改了这个第三方的new 指令就可以了
别的消费者对这个改变毫无察觉,这就达到了一个解耦的目的了
而这个第三方,我们就形象的称之为工厂,由生产者来维护

##工厂方法模式

##抽象工厂模式